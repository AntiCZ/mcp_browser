/**
 * Browser Execute Plan Tool
 * Executes a plan of tool calls generated by browser_multitool or other orchestrators
 */

import type { Tool, ToolResult } from './tool';
import type { Context } from '../context';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

// Schema for a single tool call in the plan
const toolCallSchema = z.object({
  name: z.string().describe('Name of the tool to call'),
  args: z.any().describe('Arguments to pass to the tool'),
  description: z.string().optional().describe('Optional description of this step')
});

// Schema for the execute plan parameters
const paramsSchema = z.object({
  plan: z.array(toolCallSchema).describe('Array of tool calls to execute in sequence'),
  stopOnError: z.boolean().default(true).describe('Stop execution on first error'),
  captureIntermediateResults: z.boolean().default(false).describe('Include results from each step')
});

// Result from plan execution
interface PlanExecutionResult {
  status: 'success' | 'partial' | 'error';
  executedSteps: number;
  totalSteps: number;
  results?: any[];
  errors?: Array<{
    step: number;
    tool: string;
    error: string;
  }>;
  finalSnapshot?: any;
}

/**
 * Execute a plan of tool calls
 */
export const browser_execute_plan: Tool = {
  schema: {
    name: 'browser_execute_plan',
    description: 'Execute a sequence of browser tool calls generated by browser_multitool or other orchestrators',
    inputSchema: zodToJsonSchema(paramsSchema) as any
  },
  
  handle: async (context: Context, params: z.infer<typeof paramsSchema>): Promise<ToolResult> => {
    const { plan, stopOnError, captureIntermediateResults } = params;
    
    if (!plan || plan.length === 0) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'error',
            error: 'No plan provided or empty plan'
          })
        }],
        isError: true
      };
    }
    
    const results: any[] = [];
    const errors: Array<{ step: number; tool: string; error: string }> = [];
    let executedSteps = 0;
    let lastSnapshot: any = null;
    
    // Execute each step in the plan
    for (let i = 0; i < plan.length; i++) {
      const step = plan[i];
      
      try {
        // Validate that the tool exists
        if (!context.toolbox[step.name]) {
          const error = `Tool '${step.name}' not found`;
          errors.push({ step: i, tool: step.name, error });
          
          if (stopOnError) {
            break;
          }
          continue;
        }
        
        // Execute the tool
        const result = await context.callTool(step.name, step.args);
        executedSteps++;
        
        // Capture intermediate results if requested
        if (captureIntermediateResults) {
          results.push({
            step: i,
            tool: step.name,
            description: step.description,
            result
          });
        }
        
        // If this was a snapshot tool, save it
        if (step.name === 'browser_snapshot' && result?.content) {
          lastSnapshot = result.content;
        }
        
        // Check if the result indicates an error
        if (result?.isError) {
          const errorText = typeof result.content === 'string' 
            ? result.content 
            : result.content?.[0]?.text || 'Unknown error';
          
          errors.push({ 
            step: i, 
            tool: step.name, 
            error: errorText 
          });
          
          if (stopOnError) {
            break;
          }
        }
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        errors.push({ 
          step: i, 
          tool: step.name, 
          error: errorMessage 
        });
        
        if (stopOnError) {
          break;
        }
      }
    }
    
    // Determine overall status
    const status: PlanExecutionResult['status'] = 
      errors.length === 0 ? 'success' :
      executedSteps > 0 ? 'partial' : 'error';
    
    // Build the result
    const executionResult: PlanExecutionResult = {
      status,
      executedSteps,
      totalSteps: plan.length
    };
    
    if (captureIntermediateResults && results.length > 0) {
      executionResult.results = results;
    }
    
    if (errors.length > 0) {
      executionResult.errors = errors;
    }
    
    if (lastSnapshot) {
      executionResult.finalSnapshot = lastSnapshot;
    }
    
    return {
      content: [{
        type: 'text',
        text: JSON.stringify(executionResult, null, 2)
      }],
      isError: status === 'error'
    };
  }
};